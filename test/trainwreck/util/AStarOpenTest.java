package trainwreck.util;

import Trainwreck.util.AStarNode;
import Trainwreck.util.AStarOpen;
import battlecode.common.MapLocation;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.*;

public class AStarOpenTest {
    AStarOpen open;

    @Before
    public void setup() {
        open = new AStarOpen(100);
    }


    /*
     * Add one element, check if it's in open before and after, then pop it and check if it has been removed
     */
    @Test
    public void basicTest() {
        AStarNode check = new AStarNode(null, new MapLocation(1, 1), 1, 1, 2);

        System.out.println("||||| Basic check");

        System.out.println(open.printableFCosts());
        assertFalse("Open does not contain check yet", open.isOpen(check));
        assertTrue("Open should be empty", open.isEmpty());

        open.insert(check);
        System.out.println(open.printableFCosts());

        assertTrue("Open should contain check yet", open.isOpen(check));
        assertFalse("Open should not be empty", open.isEmpty());

        AStarNode popped = open.popBest();
        System.out.println(open.printableFCosts());

        assertEquals("We should get our node back when popped", check, popped);
        assertFalse("Open should not contain check anymore", open.isOpen(check));
        assertTrue("Open should be empty", open.isEmpty());
    }

    /*
     * Play around with the heap with 3 elements, testing different operations
     */
    @Test
    public void threeTest() {
        System.out.println("||||| three check");

        AStarNode a = new AStarNode(null, new MapLocation(1, 1), 1, 1, 2);
        AStarNode b = new AStarNode(null, new MapLocation(1, 1), 1, 4, 5);
        AStarNode c = new AStarNode(null, new MapLocation(1, 1), 1, 8, 9);

        // add b first, then a, then c
        open.insert(b);
        open.insert(a);
        open.insert(c);

        // we should get items back in the right order
        System.out.println(open.printableFCosts());
        assertEquals(a, open.popBest());
        System.out.println(open.printableFCosts());
        assertEquals(b, open.popBest());
        System.out.println(open.printableFCosts());
        assertEquals(c, open.popBest());
        System.out.println(open.printableFCosts());
    }


    /**
     * More complex test
     */
    @Test
    public void complexTest(){
        System.out.println("||||| Complex check");

        AStarNode a = new AStarNode(null, new MapLocation(1, 1), 1, 1, 2);
        AStarNode b = new AStarNode(null, new MapLocation(2, 2), 1, 4, 5);
        AStarNode c = new AStarNode(null, new MapLocation(3, 3), 1, 8, 9);
        AStarNode d = new AStarNode(null, new MapLocation(4, 4), 1, 8, 9);
        AStarNode e = new AStarNode(null, new MapLocation(5, 5), 2, 8, 22000);

        // add b first, then a, then c
        open.insert(b);
        open.insert(a);
        open.insert(c);
        open.insert(d);
        open.insert(e);

        System.out.println(open.printableFCosts());
        open.updateNode(e, 2, 4,  null);

        // we should get items back in the right order
        System.out.println(open.printableFCosts());
        assertEquals(a, open.popBest());
        System.out.println(open.printableFCosts());
        AStarNode check = open.popBest();
        assertEquals(e, check);
        System.out.println(open.printableFCosts());

        assertTrue("right location", check.place.x == 5 && check.place.y == 5);
    }
}
