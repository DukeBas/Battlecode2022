package Trainwreck.bots;

import Trainwreck.util.Constants;
import battlecode.common.*;

import java.util.Objects;


public class Archon extends Robot {

    /**
     * Dimensions of the map. Map ranges between 20x20 and 60x60.
     */
    private final int mapWidth;
    private final int mapHeight;

    public Archon(RobotController rc) {
        super(rc);

        // code specific to this robot's initialisation
        this.mapWidth = rc.getMapWidth();
        this.mapHeight = rc.getMapHeight();
    }

    /**
     * This code is run once per turn (assuming we do not go over bytecode limits.)
     *
     * @throws GameActionException if an illegal game action is performed.
     */
    @Override
    void run() throws GameActionException {
        // execute communication strategy
        communicationStrategy();

        /*
         * Get number of units currently alive (or at least last turn). Reset counter to be accurate for next turn.
         */
        int ownID = rc.getID();
        int numberOfMiners = comms.getUnitCounter(ownID, RobotType.MINER);
        int numberOfSages = comms.getUnitCounter(ownID, RobotType.SAGE);
        int numberOfSoldiers = comms.getUnitCounter(ownID, RobotType.SOLDIER);
        int numberOfBuilders = comms.getUnitCounter(ownID, RobotType.BUILDER);
        comms.resetAllUnitCounters(ownID);

        // TESTING PURPOSES:
        rc.setIndicatorString("Miners: " + numberOfMiners +
                ", Sages: " + numberOfSages +
                ", Soldiers:" + numberOfSoldiers +
                ", Builders:" + numberOfBuilders);


        //Pick a direction to build in.
        Direction dir = Constants.directions[rng.nextInt(Constants.directions.length)];
        if (rng.nextBoolean()) {
            // Let's try to build a miner.
//            rc.setIndicatorString("Trying to build a miner");
            if (rc.canBuildRobot(RobotType.MINER, dir)) {
                rc.buildRobot(RobotType.MINER, dir);
            }
        } else {
            // Let's try to build a soldier.
//            rc.setIndicatorString("Trying to build a soldier");
            if (rc.canBuildRobot(RobotType.SOLDIER, dir)) {
                rc.buildRobot(RobotType.SOLDIER, dir);
            }
        }
    }

    /**
     * Communications strategy used by the archons.
     */
    @Override
    void communicationStrategy() throws GameActionException {
        super.communicationStrategy();

        rc.setIndicatorString(turnCount + "");
        if (turnCount == 1) {
            commsFirstRound();
        } else if (turnCount == 2) {
            commsSecondRound();
        }

    }

    /**
     * First round add self to known friendly archons list.
     */
    private void commsFirstRound() throws GameActionException {
        comms.addFriendlyArchon();
    }

    /**
     * Add possible enemy bases based on symmetries and other friendly bases.
     */
    private void commsSecondRound() throws GameActionException {
        /*
         * Add a potential enemy archon location for every symmetry.
         * Check for every location if it is already occupied by a friendly archon,
         * and if it is range, if so look if it is there.
         */

        MapLocation myLoc = rc.getLocation();

        // Clockwise rotations only happen on square maps!
        if (mapWidth == mapHeight) {
            // Rotation 90 degrees
            // Not necessary?

            // Rotation 180 degrees
            addSymmetricLocation(new MapLocation(mapWidth - myLoc.x - 1, mapHeight - myLoc.y - 1));

            // Rotation 270 degrees
            // Not necessary?
        }
        // Reflection horizontal
        addSymmetricLocation(new MapLocation(myLoc.x, mapHeight - myLoc.y - 1));

        // Reflection vertical
        addSymmetricLocation(new MapLocation(mapWidth - myLoc.x - 1, myLoc.y));

        MapLocation[] potentialEnemyBases = comms.getLocationsPotentialEnemyArchons();

        StringBuilder out = new StringBuilder();

        for (MapLocation loc : potentialEnemyBases) {
            out.append(loc.toString()).append(" ");
        }

        rc.setIndicatorString("pot. en.: " + out);
    }

    /**
     * Checks a location generated by using symmetry if it could contain an enemy archon, if so, add it.
     *
     * @param target location of potential enemy archon
     */
    private void addSymmetricLocation(MapLocation target) throws GameActionException {
        /*
         * Check if location is in range, if so check if there is an archon there.
         */
        if (rc.canSenseLocation(target)) {
            // it is in range!
            RobotInfo robotAtLocation = rc.senseRobotAtLocation(target);
            if (Objects.nonNull(robotAtLocation)) {
                // there's a robot here!
                if (robotAtLocation.team.equals(enemy)) {
                    // enemy spotted! Record it!
                    comms.addEnemyArchon(target, robotAtLocation.ID);
                } else {
                    // it's friendly! Disproven!
                    return;
                }
            } else {
                // no robot in sight! Disproven!
                return;
            }
        }

        /*
         * Check if location is covered by a friendly archon already.
         */
        MapLocation[] friendlyArchons = comms.getLocationsFriendlyArchons();
        for (MapLocation loc : friendlyArchons) { // check all known friendly archons
            if (target.equals(loc)) {
                // We found a friendly archon on that position! Disproven!
                return;
            }
        }

        /*
         * If we got here, it means we could not disprove an archon could be on the location,
         * add it to the list of potential enemy archon locations!
         */
        comms.addPotentialEnemyArchonLocation(target);
    }
}
