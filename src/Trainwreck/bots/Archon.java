package Trainwreck.bots;

import Trainwreck.util.Constants;
import Trainwreck.util.Status;
import battlecode.common.*;

import java.util.Objects;


public class Archon extends Robot {

    /**
     * Dimensions of the map. Map ranges between 20x20 and 60x60.
     */
    private final int mapWidth;
    private final int mapHeight;

    public Archon(RobotController rc) throws GameActionException {
        super(rc);

        // code specific to this robot's initialisation
        this.mapWidth = rc.getMapWidth();
        this.mapHeight = rc.getMapHeight();

        /*
         * Tell other archons we exist and, add possible enemy bases
         * based on symmetries and other friendly bases.
         */
        comms.addFriendlyArchon();
    }

    /**
     * This code is run once per turn (assuming we do not go over bytecode limits.)
     *
     * @throws GameActionException if an illegal game action is performed.
     */
    @Override
    void run() throws GameActionException {
        // execute communication strategy
        communicationStrategy();

        // execute unit building strategy
        unitBuildingStrategy();

        /*
         * Check if we can still repair (and thus did not build)
         */
        if (rc.isActionReady()) {
            //TODO...
        }
    }

    /**
     * Strategy for archon's unit building distribution.
     * Current strategy is:
     * Is an enemy within vision range? Build a soldier if we can!
     * Else:
     * do we have priority to build this turn?     (mechanism to ensure one archon does not spend all resources)
     * OR
     * do we currently have more than 150 lead?
     * if so:
     * Build either a miner or soldier, depending on how many units we have alive, map size, and turnCount
     */
    void unitBuildingStrategy() throws GameActionException {
        /*
         * Get number of units currently alive (or at least last turn). Reset counter to be accurate for next turn.
         */
        int ownID = rc.getID();
        int numberOfMiners = comms.getUnitCounter(ownID, RobotType.MINER);
        int numberOfSages = comms.getUnitCounter(ownID, RobotType.SAGE);
        int numberOfSoldiers = comms.getUnitCounter(ownID, RobotType.SOLDIER);
        int numberOfBuilders = comms.getUnitCounter(ownID, RobotType.BUILDER);
        comms.resetAllUnitCounters(ownID);


        // pick direction to build in
        Direction dir = buildingDirection();



        //Pick a direction to build in.
        if (rng.nextBoolean()) {
            // Let's try to build a miner.
//            rc.setIndicatorString("Trying to build a miner");
            if (rc.canBuildRobot(RobotType.MINER, dir)) {
                rc.buildRobot(RobotType.MINER, dir);
            }
        } else {
            // Let's try to build a soldier.
//            rc.setIndicatorString("Trying to build a soldier");
            if (rc.canBuildRobot(RobotType.SOLDIER, dir)) {
                rc.buildRobot(RobotType.SOLDIER, dir);
            }
        }


        // TESTING PURPOSES:
        rc.setIndicatorString("Miners: " + numberOfMiners +
                ", Sages: " + numberOfSages +
                ", Soldiers:" + numberOfSoldiers +
                ", Builders:" + numberOfBuilders);
    }

    /**
     * Determines a spot to build in. Prefers lighter terrain.
     * Returns null if no spot is free.
     *
     * @return direction to build in
     */
    Direction buildingDirection() throws GameActionException {
        Direction dir = null;
        int lowestRubble = Integer.MAX_VALUE; // initialise with really high value
        for (Direction d : Constants.directions) {
            MapLocation loc = rc.getLocation().add(d); // add direction to current position

            // if location is not on map, skip
            if (!rc.onTheMap(loc)) continue;

            if (!rc.isLocationOccupied(loc)){
                // we can build here!
                int rubbleHere = rc.senseRubble(loc);
                if (rubbleHere < lowestRubble){
                    // we found a spot with less rubble!
                    lowestRubble = rubbleHere;
                    dir = d;
                }
            }
        }

        return dir;
    }


    /**
     * Communications strategy used by the archons.
     */
    @Override
    void communicationStrategy() throws GameActionException {
        super.communicationStrategy();

        rc.setIndicatorString(turnCount + "");
        if (turnCount == 1) {
            commsFirstRound();
        }
    }

    /**
     * Checks a location generated by using symmetry if it could contain an enemy archon, if so, add it.
     */
    private void commsFirstRound() throws GameActionException {
        /*
         * Add a potential enemy archon location for every symmetry.
         * Check for every location if it is already occupied by a friendly archon,
         * and if it is range, if so look if it is there.
         */

        MapLocation myLoc = rc.getLocation();

        // Clockwise rotations only happen on square maps!
        if (mapWidth == mapHeight) {
            // Rotation 90 degrees
            // Not necessary?

            // Rotation 180 degrees
            addSymmetricLocation(new MapLocation(mapWidth - myLoc.x - 1, mapHeight - myLoc.y - 1));

            // Rotation 270 degrees
            // Not necessary?
        }
        // Reflection horizontal
        addSymmetricLocation(new MapLocation(myLoc.x, mapHeight - myLoc.y - 1));

        // Reflection vertical
        addSymmetricLocation(new MapLocation(mapWidth - myLoc.x - 1, myLoc.y));

        MapLocation[] potentialEnemyBases = comms.getLocationsPotentialEnemyArchons();

        StringBuilder out = new StringBuilder();


        // DEBUG
        for (MapLocation loc : potentialEnemyBases) {
            out.append(loc.toString()).append(" ");
        }

        rc.setIndicatorString("pot. en.: " + out);
    }

    /**
     * @param target location of potential enemy archon
     */
    private void addSymmetricLocation(MapLocation target) throws GameActionException {
        /*
         * Check if location is in range, if so check if there is an archon there.
         */
        if (rc.canSenseLocation(target)) {
            // it is in range!
            RobotInfo robotAtLocation = rc.senseRobotAtLocation(target);
            if (Objects.nonNull(robotAtLocation)) {
                // there's a robot here!
                if (robotAtLocation.team.equals(enemy)) {
                    // enemy spotted! Record it!
                    comms.addEnemyArchon(target, robotAtLocation.ID);
                } else {
                    // it's friendly! Disproven!
                    return;
                }
            } else {
                // no robot in sight! Disproven!
                return;
            }
        }

        /*
         * Check if location is covered by a friendly archon already.
         */
        MapLocation[] friendlyArchons = comms.getLocationsFriendlyArchons();
        for (MapLocation loc : friendlyArchons) { // check all known friendly archons
            if (target.equals(loc)) {
                // We found a friendly archon on that position! Disproven!
                return;
            }
        }

        /*
         * If we got here, it means we could not disprove an archon could be on the location,
         * add it to the list of potential enemy archon locations!
         */
        comms.addPotentialEnemyArchonLocation(target);
    }
}
